# Perl入学式

## 第4回 リファレンス編

___
## 諸注意
- 会場について
    - 飲食・喫煙・トイレetc

- 写真撮影について
    - 写真撮影NGな方はお手数ですが申し出てください

    - 写真はPerl普及団体の [JPA ( Japan Perl Association )](https://japan.perlassociation.org/)への活動報告に利用します

___
## 講師紹介

- 講師・サポーター紹介

___
## 皆さんで自己紹介
- せっかく今日集まったので, テーブルで自己紹介をしましょう.

- 話題は自由ですが, 以下がオススメです

    - 名前(ハンドルネーム)

    - なぜPerlを勉強してみようと思ったか

    - なぜPerl入学式に参加してみようと思ったか

___
## 今日の流れ
- 前回の復習
- リファレンス
- サブルーチンとリファレンス

___
## 用語説明

___
### シジル
$, @, %, & といった、変数名の前に付く記号を指します。

___
### リスト

    ('this', 'is', 'list', 1, 2, 3);

- このように、数値や文字列などをコンマ(`,`)で区切って並べて、括弧で囲ったものを｢リスト｣と呼びます

___
## 前回までに学んできたこと
- 変数
- 標準入力
- 演算子
- if, else 文
- for 文
- 配列
- qwショートカット
- 配列の関数（1）

___
# 前回の復習


---
# リファレンス

___
## リファレンスとは
リファレンスとは、配列やハッシュで扱うようなデータそのもの（実体）ではなく、それを指し示すもの（参照）を扱う方法です。
リファレンスを使うと、複雑なデータ構造を表現できます。

___
## 「複雑なデータ構造」とは？
ここでは、配列の中に配列が入っていたり、その中にさらにハッシュが入っているような「複数の階層を持つデータ」を指します。

___
## リファレンスの利点
たとえば、このような構造のデータを扱いたいときに、

    animal
     ├─ dog
     │    ├─ shiba
     │    └─ bulldog
     └─ cat

配列を使えば1階層分の処理は可能ですが、

    my @animal = ('dog', 'cat');
    print $animal[1]; #=> cat

複数の階層をまたぐ処理はできません。

    my @animal = (('shiba', 'bulldog'), 'cat');
    print $animal[0][1]; #=> 'bulldog' を表示したいがエラー

しかし、リファレンスを使えばこれが可能になります。

___
## リファレンスの作り方
変数のシジル（$, @, %）の前にバックスラッシュ (\\) を置くことで
各種のリファレンスを作れます。

    my $scalar     = 'scalar'; # スカラーを定義
    my $scalar_ref = \$scalar; # スカラーのリファレンスを作成

    my @array      = ( 'foo', 'bar', 'baz' ); # 配列を定義
    my $array_ref  = \@array;   # 配列のリファレンスを作成

    my %hash       = ( foo => 'bar' ); # ハッシュを定義
    my $hash_ref   = \%hash;    # ハッシュのリファレンスを作成

___
## リファレンスの簡単な作り方（1）
先ほどは、配列のリファレンスを作るために元の配列を作りました。

    my @array      = ( 'foo', 'bar', 'baz' ); # リファレンスの元になる配列
    my $array_ref  = \@array;

しかし、配列の要素を [] でくくると、直接配列のリファレンスを作れます。

    my $array_ref = [ 'foo', 'bar', 'baz' ]; # 直接リファレンスを作成

スカラー変数に代入している点に注意してください。
このように、元の配列を持たない配列リファレンスを無名配列と呼びます。
初めからリファレンスを作ることが目的の場合はこの方法が便利です。

___
## リファレンスの簡単な作り方（2）
配列と同様、ハッシュの要素を {} でくくると、直接ハッシュリファレンスを作れます。

    my $hash_ref = {
        foo => 'bar'
    };

このように、元のハッシュを持たないハッシュリファレンスを無名ハッシュと呼びます。
初めからリファレンスを作ることが目的の場合はこの方法が便利です。

___
## 配列リファレンスを使う
では、以下のデータを配列リファレンスで処理してみましょう。

    animal
     ├─ dog
     │    ├─ shiba
     │    └─ bulldog
     └─ cat

先ほどはこのように書いて失敗しましたが、

    my @animal = (('shiba', 'bulldog'), 'cat');

配列のリファレンスを使えば、意図した構造でデータを格納できます。

    my @dog = ('shiba', 'bulldog'); # 配列@dogを作る
    my $dog_ref = \@dog;            # @dogをもとに配列リファレンス$dog_refを作る
    my @animal = ($dog_ref, 'cat'); # $dog_refを含む配列@animalを作る

無名配列を使って、一度にまとめて書くこともできます。

    my @animal = (['shiba', 'bulldog'], 'cat');

___
## 配列リファレンスを使う
では、@animalから`bulldog`を取り出すにはどうすればよいでしょう？

まずは配列の復習をかねて@dogから要素を取り出してみましょう。

    print $dog[1]; #=> bulldog

同様に、配列リファレンス$dog_refから要素を取り出すにはこのようにします。

    print ${$dog_ref}[1]; #=> bulldog

なぜこのような書き方になるのでしょうか？

- じつは、配列のリファレンスを{}で囲んで先頭に@を付けると、元の配列として扱うことができます。
- つまり、`@{$dog_ref}`と`@dog`は等価です。
- よって、配列から要素を取り出すときと同様に、シジル@を$に変えて、添字[1]を付けることで、要素を取り出すことができるのです。

___
## 配列リファレンスを使う

    1. 配列@dogを作る。
    @dog = ('shiba', 'bulldog');

    2. 複雑なデータ構造を扱えるようにするため、
    配列@dogから配列リファレンス$dog_refを作る。
    my $dog_ref = \@dog;

    3. 配列リファレンス$dog_refを@{$dog_ref}とすることで、
    @dogと同等に扱えるようにする。

    4. @{$dog_ref}から要素`bulldog`を取り出す。
    print ${$dog_ref}[1]; #=> bulldog

4のように、リファレンスから元のデータにアクセスすることを「デリファレンス」と言います。

___
## 配列リファレンスを使う
配列のデリファレンスは以下のように簡単に書くこともできます。

    print $dog_ref->[1]; #=> bulldog

通常の配列から要素を取り出す形にアロー（->）を加えるだけですから、実際にはこの書き方を使う方が便利です。

    print $dog[1];       # 通常の配列から要素を取り出す場合
    print $dog_ref->[1]; # 配列リファレンスから要素を取り出す場合

___
## 配列リファレンスを使う
では、ここまでの知識を組み合わせて、@animalから要素を取り出してみましょう。

    print ${$animal[0]}[1]; #=> bulldog

アロー（->）を使えばこのように書けます。

    print $animal[0]->[1];  #=> bulldog

アローが添字に挟まれる場合は、省略してこのようにも書けます。

    print $animal[0][1];    #=> bulldog

___
## 練習問題

    animal
     ├─ dog
     │    ├─ shiba
     │    └─ bulldog
     ├─ cat
     │    ├─ mike
     │    └─ abyssinian
     └─ bird
           ├─ eagle
           └─ crow

- 次の処理をする `array_ref.pl` を作りましょう。
    1. 上記のデータ構造を表す`@animal`を作ってください。
    2. その中から`eagle`を取り出してください。
    3. 余裕があれば、他の要素も取り出してみましょう。

___
## ハッシュリファレンスを使う
以下のようなデータ構造があるときに、

    animal
     └─ dog
           ├─ name: 'Taro'
           └─ color: 'brown'

ハッシュを使えば1階層分の処理は可能ですが、

    my %dog = (
        name => 'Taro',
        color => 'brown',
    );
    print $dog{name}; #=> Taro

___
## ハッシュリファレンスを使う

複数の階層をまたぐ処理はできません。

    my %animal = (
        dog => (
            name => 'Taro',
            color => 'brown',
        ),
    );
    print $animal{dog}{name}; #=> 'Taro'を表示したいがエラー

しかし、リファレンスを使えばこれが可能になります。

___
## ハッシュリファレンスを使う
ハッシュリファレンスを使えば意図した構造でデータを格納できます。

    my %dog = (
        name => 'Taro',
        color => 'brown',
    );
    my $dog_ref = \%dog; # %dogをもとにハッシュリファレンス$dog_refを作る

    my %animal = (
        dog_key => $dog_ref,
    ); # $dog_refをvalueとする%animalを作る

無名ハッシュを使って、一度にまとめて書くこともできます。

    my %animal = (
        dog_key => {
            name => 'Taro',
            color => 'brown',
        },
    );

___
## ハッシュリファレンスを使う
では、%animalから`Taro`を取り出すにはどうすればいいでしょうか？

まずハッシュの復習をかねて%dogから要素を取り出してみましょう。

    print $dog{name}; #=> Taro

同様に、ハッシュリファレンス$dog_refから要素を取り出すにはこのようにします。

    print ${$dog_ref}{name}; #=> Taro

なぜこのような書き方になるのでしょうか？

- じつは、ハッシュリファレンスを{}で囲んで先頭に%を付けると、元のハッシュとして扱うことができます。
- つまり、`%{$dog_ref}`と`%dog`は等価です。
- よって、ハッシュから要素を取り出すときと同様に、シジル%を$に変えて、{key}を付けることで要素を取り出すことができるのです。

___
## ハッシュリファレンスを使う

    1. ハッシュ%dogを作る。
    my %dog = ( name => 'Taro', color => 'brown',);

    2. 複雑なデータ構造を扱えるようにするため、
    ハッシュ%dogからハッシュリファレンス$dog_refを作る。
    my $dog_ref = \%dog;

    3. ハッシュリファレンス$dog_refを%{$dog_ref}とすることで、
    %dogと同等に扱えるようにする。

    4. %{$dog_ref}から要素`Taro`を取り出す。
    print ${$dog_ref}{name}; #=> Taro

___
## ハッシュリファレンスを使う
ハッシュのデリファレンスは以下のように簡単に書くこともできます。

    print $dog_ref->{name}; #=> Taro

通常のハッシュから要素を取り出す形にアロー（->）を加えるだけですから、実際にはこの書き方を使う方が便利です。

    print $dog{name};       # 通常のハッシュから要素を取り出す場合
    print $dog_ref->{name}; # ハッシュリファレンスから要素を取り出す場合

___
## ハッシュリファレンスを使う
では、ここまでの知識を組み合わせて、%animalから`Taro`を取り出してみましょう。

    print ${$animal{dog_key}}{name}; #=> Taro

アロー（->）を使えばこのように書けます。

    print $animal{dog_key}->{name}; #=> Taro

アローが{key}に挟まれる場合は、省略してこのようにも書けます。

    print $animal{dog_key}{name}; #=> Taro

___
## 練習問題

    animal
     ├─ dog
     │    ├─ name: 'Taro'
     │    └─ color: 'brown'
     └─ cat
           ├─ name: 'Tama'
           └─ color: 'white'

- 次の処理をする `hash_ref.pl` を作りましょう。
    1. 上記のデータ構造を表す`%animal`を作ってください。
    2. その中から`white`を取り出してください。
    3. 余裕があれば、他の要素も取り出してみましょう。

___
## リファレンスに代入する
配列やハッシュと同様、リファレンスにも新たな要素を代入できます。

    animal
     ├─ dog
     │    ├─ shiba
     │    └─ bulldog
     └─ cat

上記のデータ構造における`dog`の3番目の要素に`poodle`を加えたい場合は、このようにします。

    my @animal = (['shiba', 'bulldog'], 'cat');
    ${$animal[0]}[2] = 'poodle'; # 新たな要素を代入

アロー記法を使って、このように書くこともできます。

    $animal[0]->[2] = 'poodle';
    $animal[0][2] = 'poodle';

___
## リファレンスに代入する

    animal
     └─ dog
           ├─ name: 'Taro'
           └─ color: 'brown'

上記の構造における`dog`に、`key: value`の関係が`age: 3`になる新たな要素を代入する場合はこのようにします。

    my %animal = (
        dog => {
            name => 'Taro',
            color => 'brown',
        },
    );
    ${$animal{dog}}{age} = 3; # 新たな要素を代入

無名ハッシュを使って、このように書くこともできます。

    $animal{dog}->{age} = 3;
    $animal{dog}{age} = 3;

___
## リファレンスの中身を全部見る
データ構造の中身を出力したいとき、ここまではその要素の一部だけを取り出してきました。

しかし、中身を一度にすべて見たい場合はどうすればいいでしょうか？

ためしに、以下のハッシュリファレンス（無名ハッシュ）を普通にprintしてみましょう。

    my $dog = {
        name => 'Taro',
        color => 'brown',
    };
    $dog->{age} = 3;

    print $dog; #=> HASH(0x7f8aa2029380)

___
## リファレンスの中身を全部見る

- `HASH(0x7f8aa2029380)` のような出力が得られたと思います。(括弧内の英数字は実行環境によって異なります)
- 今回の例はハッシュリファレンスなのでHASH()となっていますが、スカラーリファレンスならSCALAR()、配列リファレンスならARRAY() と表示されます。
- 初めに説明したように、リファレンスとはデータそのもの（実体）ではなく、それを指し示すもの（参照）を扱うものでした。
- じつはHASH() の括弧内の英数字は、実体が格納されているアドレス（場所の情報）です。
- print関数は実体を出力する働きをもつため、アドレスが表示されてしまうのです。

___
## Data::Dumperを使う
このようなときは、`Data::Dumper` モジュールを使えばリファレンスの中身を一括表示（ダンプ）できます。

    use Data::Dumper; # 最初にモジュールの使用を宣言
    my $dog = {
        name => 'Taro',
        color => 'brown',
    };
    $dog->{age} = 3;
    print Dumper($dog); # Data::Dumperを使ってprint

    # 出力結果↓
    # $VAR1 = {
    #         'name' => 'Taro',
    #         'color' => 'brown',
    #         'age' => 3
    #         };

___
## Data::Dumperを使う
`Data::Dumper` には、リファレンスを渡します。

よって、ハッシュの中身を見たいときには、リファレンスにしたものを渡します。

    my %dog = (
        name => 'Taro',
        color => 'brown',
    );
    $dog{age} = 3;

    print Dumper(\%dog); # リファレンスを渡す

`Data::Dumper` は、新たな要素を代入した後に中身を確かめたいときや、データの中身を把握していないときなどに役立つので、覚えておきましょう。

___
## Perlとモジュール
Perlには`Data::Dumper`の他にも有用なモジュールが数多く存在します。
その一例を紹介します。

- `Encode`
    - 日本語などの「マルチバイト文字」入出力に必須となるモジュール。絵文字も利用可能。
- `JSON::PP`
    - インターネットでの情報のやり取りに利用される「JSON形式」データの作成・解読
- `List::Util`
    - リスト(配列)でよく利用される最小, 最大, 合計などを求める関数を含む
- `HTTP::Tiny`
    - 必要最小限の機能を持つWebクライアント
___
## 最終問題
- 次の処理をする `region_ref.pl` を作りましょう。
    1. 以下のデータ構造を表す`%japan`を作ってください。

```
    japan
     ├─ tokyo
     │    ├─ gotanda
     │    └─ shibuya
     ├─ osaka
     │    └─ shinsaibashi
     ├─ okinawa
     │    ├─ naha
     │    └─ yomitan
     ├─ hokkaido
     │    ├─ sapporo
     │    └─ obihiro
     └─ fukuoka
           └─ hakata
```
___
## 最終問題
2. 1. で作ったデータから、 `gotanda` と `sapporo` を出力してください。
3. `osaka` の中に `umeda` を追加してください。
4. その後、`Data::Dumper` を使って `%japan` 全体の中身を出力してください。

---
## 復習問題
- <https://github.com/perl-entrance-org/workshop-2019/blob/master/3rd/practice.md>
  - 今回の内容を復習できる問題集です。
  - 不明点があれば、気軽にサポーターに質問してください。

---
# サブルーチンとリファレンス

___
## 配列を引数に
    my @hoge = qw/ hoge fuga /;
    my @foo  = qw/ foo bar baz /;
    sub output {
        my (@array1, @array2) = @_;
        print '@array1 = ' . join(',', @array1) . "\n";
        print '@array2 = ' . join(',', @array2) . "\n";
    }
    output(@hoge, @foo);

- サブルーチンの引数として, 2つの配列を与えてみましょう.
    - この時, 実行結果はどうなると思いますか? 考えてみましょう.

___
## 配列を引数に

    @array1 = hoge,fuga,foo,bar,baz
    @array2 =

- 実行結果はこのようになります!

___
## 配列を引数に

    @array1 = hoge,fuga
    @array2 = foo,bar,baz

- このようになる, と予測した方は多いのではないでしょうか?

___
## なぜ!?

    my @array1 = qw/ hoge fuga /;
    my @array2 = qw/ foo bar baz /;
    my @array  = (@array1, @array2);
    # @array = ('hoge', 'fuga', 'foo', 'bar', 'baz');

- これは, 複数の配列をリストで評価すると, 展開されて元の配列の区別がなくなってしまう為です.
- 先程の場合, `@_`の中身は`('hoge', 'fuga', 'foo', 'bar', 'baz')になります.
    - Perlは元の配列の`@hoge`と`@foo`の境目が`@_`のどこにあるかわからないので, 全て`@array1`に突っ込もうとします.

___
## そこで!

- この問題を解決する為に, リファレンスを利用することができます!

___
## リファレンス渡し

    my @hoge = qw/ hoge fuga /;
    my @foo  = qw/ foo bar baz /;
    sub output {
        my ($array1, $array2) = @_;
        print '@$array1 = ' . join(',', @$array1) . "\n";
        print '@$array2 = ' . join(',', @$array2) . "\n";
    }
    output(\@hoge, \@foo);

- 8行目で配列のリファレンスを渡しているので, 4行目では2つのスカラ変数で引数を受け取っています.

___
## リファレンス渡し

    @$array1 = hoge,fuga
    @$array2 = foo,bar,baz

- 実行してみると, 期待通りの結果を取得することができました.

___
## リファレンス渡し

- 配列と同様に, ハッシュもリファレンスで渡すことができます.
- 更に, リファレンスで渡す場合, 配列をそのまま渡した時のように, データのコピーが発生しません.
- 引数として与えた配列･ハッシュの構造をそのままサブルーチンに渡すことができ, データのコピーが発生しない｢リファレンス渡し｣ですが, 1つ注意点があります.

___
## 中身の書き換え

    my %hash = ( alice => 'fool' );
    print $hash{alice}; # => fool
    fix(\%hash);
    print $hash{alice}; # => clever
    sub fix {
        my $hash = shift;
        $hash->{alice} = 'clever';
    }

- サブルーチンに渡される配列･ハッシュのリファレンスは, サブルーチンの外側にある配列･ハッシュの実体(この場合, `%hash`)を指しているので, サブルーチンの中でデータ構造を書き換えると, 外側の実体にも影響が出てしまいます.

___
## 練習問題
- 配列とハッシュをそれぞれ1つずつ定義してから, 第1引数に配列のリファレンス, 第2引数にハッシュのリファレンスを受け取り, その中身を出力する(for文などを利用して...), `output_array_and_hash`というサブルーチンを書いてみよう.
- このコードは, `output_array_and_hash.pl`という名前で保存するようにしましょう.