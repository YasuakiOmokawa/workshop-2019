# Perl入学式

## 第3回 サブルーチン/正規表現編

___
## 諸注意
- 会場について
    - 飲食・喫煙・トイレetc

- 写真撮影について
    - 写真撮影NGな方はお手数ですが申し出てください

    - 写真はPerl普及団体の [JPA ( Japan Perl Association )](https://japan.perlassociation.org/)への活動報告に利用します

___
## 講師紹介

- 講師・サポーター紹介

___
## 皆さんで自己紹介
- せっかく今日集まったので, テーブルで自己紹介をしましょう.

- 話題は自由ですが, 以下がオススメです

    - 名前(ハンドルネーム)

    - なぜPerlを勉強してみようと思ったか

    - なぜPerl入学式に参加してみようと思ったか

___
## 今日の流れ
- 前回の復習
- サブルーチン
- 正規表現
- 正規表現と置換
- 正規表現とメタ文字
- 正規表現のオプション

---
# 前回の復習
- 2019年度 第2回の練習問題からセレクト予定


---
# サブルーチン

___
## サブルーチン
Perlには, これまで使ってきた `print` や `join` など, Perlが提供する関数(組み込み関数)が用意されています.

Perlに組み込まれていない, 独自の関数を作成し利用する場合 **サブルーチン** を使います.

___
## サブルーチンの定義
それでは, 早速サブルーチンを定義していきましょう.

今回は, 常に末尾に改行(`\n`)を付与しながら文字列を表示する `say` というサブルーチンを定義してみます.

___
## サブルーチンの定義
```perl
    sub say {
        my $str = shift @_;
        print "$str\n";
    }
    say("hello, world!");    # hello, world![改行]
```

それでは, 詳しく見て行きましょう.

___
## サブルーチンの定義
```perl
    sub say { ... }
```

- Perlでサブルーチンを定義する為には, `sub サブルーチン名 { ... }` と書きます.

- 末尾の `}` の後に, `;` を書く必要はありません.

- サブルーチン名として使える文字は大文字･小文字の英数字と, アンダースコア( `_` )です.
    - 但し, サブルーチン名の先頭は英文字か `_` でなければなりません.
    - これは変数名でも同様です

___
## サブルーチンの定義
```perl
    sub output_data { ... }
    sub is_study { ... }
    sub MAX_LINE { ... }
```

Perlでは複数の単語でサブルーチン名を構築する時, 単語どうしを `_` で繋げる場合が多いです.

この `_` でつなげる命名規則を **スネークケース** といいます.

___
## クイズ
```perl
    sub hoge! { ... }

    sub _hoge { ... }

    sub 123_hoge { ... }

    sub hoge_123 { ... }
```

この中で, サブルーチン名として利用可能なものはどれでしょうか？

___
## 正解は?
```perl
    sub hoge! {...}       #  ! はサブルーチン名に利用できない

    sub _hoge {...}       # 利用可能

    sub 123_hoge {...}    # 先頭は英字 または _ である必要がある

    sub hoge_123 {...}    # 利用可能
```

正解は`_hoge`と`hoge_123`です.

___
## サブルーチンの呼び出し
```perl
    say('hoge');
```

定義したサブルーチンは, サブルーチン名の後ろに `( )` を付けて呼び出します.

サブルーチンに引数を渡す場合, `( )`の中に書きます.

> プログラムに渡される情報, 値などを**<ruby><rb>引数</rb><rp>（</rp><rt>ひきすう</rt><rp>）</rp></ruby>**と言う
> <div style="text-align: right;">第2回より</div>

___
## サブルーチンの引数
```perl
    sub say {
        my $str = shift @_;    # @_ の中身は ('hoge')
        print "$str\n";
    }
    say('hoge');
```


サブルーチンに与えられた引数は, `@_` という配列に格納されます.

2行目では, `shift` を使って, この `@_` の先頭の要素を取得しています.

このサブルーチンを `say('hoge');` のように呼んだ場合, `@_` の中身は `('hoge')` になるので, `$str` には `hoge` という文字列が入ります.

___
## サブルーチンの引数
```perl
    sub say {
        my $str = shift;    # @_ が省略されている
        print "$str\n";
    }
```

サブルーチンに与えられた引数が格納されている`@_`は, 省略することができます.

以下の2つの書き方は同じ意味のコードになります

    my $str = shift;

    my $str = shift @_;

___
## サブルーチンの位置
```perl
    say('hoge');
    # サブルーチン呼び出しが先
    #
    # サブルーチン定義が後にあるコード
    sub say {
        my $str = shift @_;
        print "$str\n";
    }
```

同じファイル内であれば, サブルーチンは定義された場所を問わず呼び出しが可能です.

ファイル末尾にサブルーチンがまとまっている方が見やすい場合は, このスタイルで書きましょう.

___
## 2つの引数を受け取るサブルーチン
今までは1つの引数を受け取るサブルーチンを作成してきました.

サブルーチンに複数の引数を与える時は, 配列のように `,` で区切って渡します.

今回は2つの引数を受け取り, その和を返すサブルーチン `add` を作成します.

`add`サブルーチンの定義と呼び出しは, このように書くことができます.


```perl
    my $result = add( 2, 5 );
    print "$result\n";  # 7

    sub add {
        my ( $left, $right ) = @_;
        return $left + $right;
    }
```

___
## サブルーチンの引数
```perl
    my $result = add( 2, 5 );       # 複数の引数は配列のように , で区切って渡す
    print "$result\n";  # 7

    sub add {
        my ( $left, $right ) = @_;  # 複数の引数を受け取る時の例
        return $left + $right;
    }
```

1. サブルーチン `add` に複数の引数(`2` と `5` )が与えられて呼び出される.

1. サブルーチン内の `@_` の中は `( 2 , 5 )` となっている

1. 左辺では `my` でまとめて2つの変数 `$left, $right`を初期化して, その値として `@_` から `$left` に `2` , `$right` に `5` が代入される

1. `return` により `$left` と `$right` を足した結果が返される. これを **返り値** という

1. 返り値が `$result` に格納される

___
## サブルーチンの引数
サブルーチンの引数を1つ1つ受け取るときの書き方です。

```perl
    my $result = add( 2, 5 );       # 複数の引数は配列のように , で区切って渡す
    print "$result\n";  # 7

    sub add {
        my $left   = shift @_ ;  # 最初の引数 2 を受け取る
        my $right  = shift @_ ;  # 次の引数 5 を受け取る
        return $left + $right;
    }
```

サブルーチンの引数を受け取る方法として, 以下の2つは同じ動きをするコードです.

```perl
        my $left   = shift @_ ;  # 最初の引数 2 を受け取る
        my $right  = shift @_ ;  # 次の引数 5 を受け取る
```

```perl
        my ( $left, $right ) = @_;  # 複数の引数をまとめて受け取る時の例
```

___
## サブルーチンの引数
```perl
    sub say {
        my $str = @_;    # my ($str) = @_; と書くべきところ
        print "$str\n";
    }
    say('hello');        # 1
```

`shift` を使わず, `@_` をそのまま右辺に置く場合は, 左辺の丸括弧 `( )` は忘れないようにしましょう。

上記の例では左辺の丸括弧 `( )` を忘れたために, 引数の「中身」ではなく, 引数の「数」が `$str` に格納されてしまっています.

以下のコードで起きていることと同じことが起きていると考えてください.

```perl
    my @array  = qw( Alice Bob Chris );
    my $scalar = @array;
    print "$scalar\n";    # 3
```

___
## 複数個のreturn
```perl
    same( 1, 1 );    # true
    same( 0, 1 );    # false

    sub same {
        my ( $i, $j ) = @_;
        if ( $i == $j ) {
            print "true\n";    # $i == $j なら表示
            return 1;
        }
        else {
            print "false\n";    # $i == $j ではないなら表示
            return 0;
        }
        print "!?\n";           # 絶対に表示されない!
    }
```

`return` はサブルーチンの中に複数個書くことができます

処理が `return` に到達した場合, それ以降の処理は一切行われません. すぐさま値を返してサブルーチンを終了します.

___
## 複数の返り値
```perl
    sub add_and_min {
        my ( $left, $right ) = @_;

        my $add = $left + $right;
        my $min = $left - $right;

        return ( $add, $min );

    }

    my ( $add, $min ) = add_and_min( 5, 4 );
    print "$add\n";    # 9
    print "$min\n";    # 1
```

サブルーチンは, 返り値にリストを返し, 複数個の値を返すこともできます.

___
## returnを書かないアンチパターン
```perl
    sub add {
        my ( $left, $right ) = @_;
        $left + $right;     # 良くない書き方
    }
```

サブルーチンの中に `return` がない場合, サブルーチンの返り値は, 最後に評価された処理の結果を返します.

上記の例の場合, `$left + $right` の計算結果を返します.

値を返すという意図を明確にするため, `return` で返り値を指定しましょう.

___
## 練習問題
次のような機能を持つコードを, `simple_calc.pl`という名前で作成しよう.

- 2つの数値の引数の和を計算する`add`と同様に, 2つの引数の差を計算する`min`, 積を計算する`mul`, 商を計算する`div`というサブルーチンを作ってみよう.

- これらのサブルーチンを利用して, 正しく実装できているか確認するコードを書いてみよう.

___
次のような機能を持つコードを, `simple_fizzbuzz.pl`という名前で作成しよう.

- 1つの数値の引数を受け取る

- その数が 3 で割り切れれば `fizz` と表示する

- その数が 5 で割り切れれば `buzz` と表示する

- その数が 15 で割り切れれば `fizzbuzz` と表示する

- 正しく実装できているか確認するコードを書く



---
# 正規表現

___
## 正規表現
- ここでは, データ処理の強い味方｢正規表現｣を取り上げます.
    - 正規表現を使うことで, 文字列を自由自在に検出したり, 置き換えたりすることができます.
- 正規表現は非常に複雑なので(正規表現だけで分厚い1冊の技術書が書けるほどです), Perl入学式で全てを紹介することはできませんが, コードを書く上でよく使う｢基本的な部分｣を中心に, 紹介していきます.

___
## パターンマッチ
    my $str = 'papix loves perl!';
    if ($str =~ /perl/) {
        print "'$str'は'perl'を含みます.";
    }

- `$str =~ /perl/`は, `$str`の中に｢perl｣という文字列が含まれるなら真, そうでないなら(含まれないなら)偽, になります.
- この, `/`に囲まれた, 文字列のパターンを表現するものが｢正規表現｣です.

___
## パターンマッチ

    my $str = 'papix loves perl!';
    if ($str eq 'perl') {
        print "'$str'は'perl'です.";
    }
    if ($str =~ /perl/) {
        print "'$str'は'perl'を含みます.";
    }

- `eq`は完全一致か否かしか判定できません. しかし正規表現とパターンマッチを活用することで, ｢xxxという文字列を含む｣や, その逆の｢xxxという文字列を含まない｣といった複雑な判定を行うことができます.

___
## パターンマッチ
    my $str = 'papix loves perl!';
    if ($str !~ /ruby/) {
        print "'$str'は'ruby'を含みません.";
    }

- `$str !~ /ruby/`と書くことで, `$str`の中に｢ruby｣という文字列を含まないなら真, そうでないなら(含むなら)偽, になります.

___
## 任意の1文字
    my $ans = 'y';
    if($ans =~ /[yY]/) {
        print "文字列にはyないしYが含まれています.\n";
    }

- `[`と`]`で文字をくくると, []の中の任意の1文字にマッチします.
- よって`/[yY]/`は, `y`ないし`Y`にマッチします.

___
## 任意の1文字(否定)
    my $ans = 'n';
    if($ans =~ /[^yY]/) {
        print "文字列にはyないしY以外の文字が含まれています.\n";
    }

- `[`と`]`で文字をくくり, その先頭に`^`を置くと, []の中にない任意の1文字にマッチします.
- よって`/[^yY]/`は, `y`ないし`Y`以外の文字にマッチします.
- `^`は, 必ず`[`の後に置いて, `[^`の形で用います.

___
## 任意の1文字(連続)
    my $ans = 'b';
    if($ans =~ /[a-c]/) {
        print "文字列にはa, b, cのいずれかが含まれています.\n";
    }

- `[`と`]`の中で, 文字の間に`-`を挟むことによって, 文字列の範囲を表現できます.
- この場合, `[a-c]`は`[abc]`と同じ意味になります. `[1-5]`のように, 数値に対しても利用できます.
- `[a-z0-9]` という複数の文字列の範囲を表現することもできます. この場合「アルファベット小文字か数字の1文字」を表します.

___
## 任意の1文字(応用)
    my $ans = 'yes';
    if($ans =~ /[Yy]es/) {
        print "Yes が選択されました\n";
    }

- 任意の1文字を応用すると, 一部だけ大文字小文字を許容する正規表現が書けます.

___
## ワイルドカード
    my $ans = 'get';
    if($ans =~ /g.t/) {
        print "マッチ!\n";
    }

- `.`は, 改行文字(`\n`)を除く, 任意の1文字にマッチします.
- よって`/g.t/`は, `get`や`got`など, `g+任意の1文字+t`にマッチします.
    * `.`がマッチするのは1文字だけなので, `goat`などはマッチしません.
    * また, `gt`にもマッチしません.

___
## 量指定子'?'
    my $ans = 'gt';
    if($ans =~ /g.?t/) {
        print "マッチ!\n";
    }

- `?`は, その直前の要素が0個または1個の場合にマッチします.
    * 例えば`ab?`は, `a`または`ab`にマッチします.
- よって`/g.?t/`は, `g+任意の1文字+t`に加え, `gt`にもマッチします.

___
## 量指定子'+'
    my $ans = 'get';
    if($ans =~ /g.+t/) {
        print "マッチ!\n";
    }

- `+`は, その直前の要素が1個以上の場合マッチします.
    * 例えば`ab+c`は, `abc`や`abbbbc`などにマッチしますが, `ac`にはマッチしません.
- よって, `/g.+t/`は, `g+任意の1文字以上+t`にマッチします.

___
## 量指定子'*'
    my $ans = 'great';
    if($ans =~ /g.*t/) {
        print "マッチ!\n";
    }

- `*`は, その直前の要素が0個以上の場合マッチします.
    * 例えば`ab*c`は, `ac`や`abc`, `abbbbbc`などにマッチします.
- よって`/g.*t/`は, `g`で始まり`t`で終わる全てのフレーズとマッチします(`great`など).

___
## 柔軟な量指定子
    my $str = 'Gyaaaaaaaaa!';
    print "マッチ!\n" if $str =~ /a{5,}/;
    # マッチする
    my $str2 = 'Gyaa!';
    print "マッチ!\n" if $str2 =~ /a{5,}/;
    # マッチしない

- `{m,n}` ... その直前の要素がm回以上, n回以下繰り返す場合マッチ
- `{m,}` ... その直前の要素がm回以上繰り返す場合マッチ
- `{m}` ... その直前の要素がm回繰り返す場合マッチ

___
## 練習問題

- 引数として文字列を受け取り, その文字列に`perl`ないし`Perl`が含まれるなら｢Perl Monger!｣と表示するサブルーチン`perl_checker`を書いてみましょう.
- コードは, `perl_checker.pl`という名前で保存するようにしましょう.

___
## マッチした文字列の取得
    my $str = '私は perl が好きです.';
    if($str =~ /私は (.+) が好き/) {
        print "彼は, $1 が好きです.\n";
        # => 彼は, perl が好きです
    }

- 正規表現のパターンを`()`を囲むと, そのパターンに一致する文字列を取得することができます.
- 例えばこの場合, $1には`perl`が入り, `彼は, perl が好きです.`と表示されるはずです.

___
## マッチした文字列の取得
    my $str = '私は perl と 旅行 が好きです.';
    if($str =~ /私は (.+) と (.+) が好き/) {
        print "彼は, $1 と $2 が好きです.\n";
        # => '彼は, perl と 旅行 が好きです.'と表示.
    }

- 複数の`()`が存在する場合, 先頭から`$1`, `$2`... で取得することができます.

___
## マッチングの原則
    my $str = 'Hello hoge! Hello fuga!';
    if($str =~ /Hello (.+)!/) {
        print "Nice to meet you, $1!\n";
    }

- `hoge`を抜き出して`Nice to meet you, hoge!`としたいので, このようなコードを書きました.
- しかしながら, 実際には`Nice to meet you, hoge! Hello fuga!`と表示されます.

___
## マッチングの原則
    my $str = 'Hello hoge! Hello fuga!';
    if($str =~ /Hello (.+?)!/) {
        print "Nice to meet you, $1!\n";
    }

- これは, 正規表現が｢なるべく長くマッチする(最長マッチ)｣ようになっている為です.
- このように, 量指定子のあとに`?`を付けて, 最短マッチにすれば, `Nice to meet you, hoge!`と出力されるはずです.

___
## 練習問題
    my $words_ref = [
        'alice loves meat!',
        'bob loves sushi!',
    ];

- このような配列のリファレンスを受け取り, リファレンスに格納された文字列について, ｢loves｣の後に記述されている好きな食べ物の単語を正規表現で取得し, ｢alice -> meat｣, ｢bob -> sushi｣のように表示するサブルーチン, `love_food`を書いてみよう.
- このコードは, `love_food.pl`という名前で保存するようにしましょう.

---
# 正規表現と置換

___
## 置換
    my $str = 'abc def ghi abc';
    $str =~ s/abc/ABC/;
    # $str = 'ABC def ghi abc';

- `s/PATTERN/REPLACE/`で, `PATTERN`を`REPLACE`に置換します.
    - `PATTERN`を記述する為に, 正規表現を利用することができます.
- `$str`に含まれる全ての`PATTERN`を置換したい場合, `s/PATTERN/REPLACE/g`と表記します.
    - 最後にオプションとして`g`を付けることで, 繰り返し評価･置換します.

___
## 変数の使用

    my $str = 'perl ruby python';
    my $pattern = 'perl';
    if($str =~ /$pattern/) {
        print "'$str'には'$pattern'が含まれます.\n";
    }

- このように, 正規表現として変数を利用することもできます.

___
## 練習問題
    my $str = 'I love ruby';

- この`$str`に格納された文字列を, 置換を利用して, ｢I love perl｣に書き換えるようなコードを書いてみましょう.
    - コードは, `regexp_replace.pl`という名前で保存しましょう.

---
# 正規表現とメタ文字

___
## メタ文字
- メタ文字を使うと, ｢数字とマッチ｣や｢アルファベットとマッチ｣などといった正規表現を, より簡単に表現することができます.
- ここでは, よく使うメタ文字を紹介します.

___
## メタ文字(1)

- `\w` ... アルファベット, 数字, アンダーバーの1文字
    * `[a-zA-Z0-9_]`と同じ意味です.

- `\W` ... アルファベット, 数字, アンダーバー以外の1文字
    * `[^a-zA-Z0-9_]`と同じ意味です.

- `\d` ... 数字の1文字
    * `[0-9]`と同じ意味です.

- `\D` ... 数字以外の1文字
    * `[^0-9]`と同じ意味です.

___
## メタ文字(1)
- `\s` ... 空白文字にマッチ
    * `[ \n\r\f\t]`と同じ意味です.

- `\S` ... 空白文字以外にマッチ
    * `[^ \n\r\f\t]`と同じ意味です.

___
## メタ文字(1) 使い方

    my $str1 = '2019年7月22日';
    if($str1 =~ /(\d+)年(\d+)月(\d+)日/) {
        print "$1/$2/$3";
        # "2019/7/22"と表示される.
    }
    my $str2 = "この    文章  は\n 読みにく\nい    で  \t    す\n";
    $str2 =~ s/\s+//g;
    # $str2 = "この文章は読みにくいです";

- `\s`を使えば, 余分な空白や改行を抜き取ることができます.

___
## メタ文字(2)
- `|` ... 選択一致（OR検索）
    * 例えば, `abc|def|ghi`は, `abc`, `def`, `ghi`のいずれかにマッチします.
- `(PATTERN)` ... グループ化
    * 正規表現をグループ化します.
    * 先に説明したように, `()`の中のパターンにマッチした文字列は記憶され, `$1`や`$2`のように後で参照することができます(後方参照).
- `(?:PATTERN)` ... 後方参照しないグループ化
    * 正規表現をグループ化しますが, `()`の中のパターンにマッチした文字列は記憶されません.

___
## メタ文字(2) 使い方
    my $str = 'perl is good!';
    if($str =~ /(?:perl|ruby|python) is (good|bad)!/) {
        print "評価は $1 です!\n";
        # "評価は good です!"と表示される.
    }

- `perl`, `ruby`, `python`を`|`でつなぎ, `(`と`)`で囲うことで, 選択一致をグループ化しています.
- 更に, `(?:`とすることで, 後方参照しないようにしています.
    * その為, $1は`(good|bad)`のパターンにマッチした文字列となります.

___
## 正規表現のメタ文字(3)
    my $str = 'john is dead.';
    if ($str =~ /dead\./) {
        print "match!\n";
    }

- `\` ... メタ文字を無効化する
    - 正規表現の中で特殊な意味を持つ文字(例えば`/`や`.`など)を無効化します.
- この場合. `$str =~ /dead./`は, `john is dead!`などでもマッチしてしまう(`.`は任意の1文字とマッチ, なので).
- `\.`のようにすれば `.`そのものとのマッチができます.

___
## アンカー
- アンカーは, 行頭や行末など, 文字列の特定の位置とマッチします.
    - `^` ... 行頭
    - `$` ... 行末

___
## アンカー 使い方
    my $str = 'john is great';
    # 行頭に'john'がある場合のみマッチ
    if ($str =~ /^john/) {
        print "match!\n";
    }

___
## 区切り記号の変更(1)
    my $str = '/usr/local/bin/perl';
    if ($str =~ m|bin/perl|) {
        print "match!\n";
    }

- 正規表現は`/`で区切りますが, `/`だと不都合な場合も多いです(例えば, URLを表記する場合など. 全ての`/`をエスケープする必要がある).
- そこで, `m//`のように, 先頭に`m`を付けると, 任意の記号のペアを区切り記号として利用することができます.
- 今まで見てきた通り, 区切り記号が `/` の場合のみ `m` を省略できます.
- この場合, `|`を区切り記号にしています. よって, `/`をエスケープする必要はありません.

___
## 区切り記号の変更(2)
    my $str = '/usr/local/bin/perl';
    $str =~ s|/usr/local/bin/|/usr/bin/|;

- 置換の場合, このようにできます.

___
## 区切り文字の変更(3)
    my $str = '/usr/local/bin/perl';
    $str =~ s{/usr/local/bin/}{/usr/bin/};

- m// や s/// で区切り文字を変える場合, 括弧を使う場合は上記のように対応する閉じ括弧で区切ることになります.

---
# 正規表現のオプション

___
## 繰り返してマッチ(g)
    my $str = 'Hello, hoge! Hello, fuga!';
    my @name = ($str =~ /Hello, (\w+?)!/g);
    # @name = ('hoge', 'fuga'); となる.

- `g`は, 正規表現のマッチングを繰り返し行います.
- また, 正規表現に`()`が含まれる場合, マッチした文字列のうち`()`の中に含まれる文字列をリストとして返します.

___
## 繰り返してマッチ(g)
    my $str = 'Hello, hoge! Hello, fuga!';
    my $str =~ s/Hello/Good morning/g;

- 置換の部分で説明したように, `s///g`とすると, 置換の処理を繰り返し行なってくれます.

___
## 大文字/小文字を区別しない(i)
    my $str = 'John and Beth';
    if ($str =~ /john/i) {
        print "match!\n";
    }

- `i`は, 正規表現中のアルファベットの大文字･小文字を区別せずにマッチングを行います.
- よって, `/john/i`は, `john`はもちろん, `John`や`JOHN`, `jOhN`などにもマッチします.

___
# 練習問題 (1/3)

    while (chomp(my $input = <STDIN>)) {
        ...
    }

- 上記のコードは, 標準入力から入力された文字列を, ひたすら`$input`に代入するコードである.
- このコードの`...`の部分を, 次の条件を満たすように書き換えてみよう.
- この問題のコードは, `while_input.pl`という名前で保存するようにしよう.

___
# 練習問題 (2/3)
- 文字列が`0`の場合, ループを抜ける(`last`を使って...).
- 文字列が`perl`ないし`Perl`を含む場合, ｢Find Perl!｣と表示する.
- 文字列に大文字小文字問わず, `python`の文字列が含まれる場合, ｢Find Python!｣と表示する.
- 文字列に`perl`ないし`ruby`ないし`python`が含まれる場合, ｢Love Programming!｣と表示する.
___
## 最終問題
- 次の処理をする `region_ref.pl` を作りましょう。
    1. 以下のデータ構造を表す`%japan`を作ってください。

___
# 練習問題 (3/3)
- 文字列の先頭に`papix`がある場合, ｢Find papix!｣と表示する.
- 文字列に`Hello`が含まれる場合, その後に続く単語`xxxx`を使って｢Hello! xxxx!｣と表示する.
    - 例えば, 文字列に｢Hello papix｣が含まれる場合, ｢Hello! papix!｣と表示すればOKです.

---
# 質問タイム

---
# 復習問題
- <https://github.com/perl-entrance-org/workshop-2019/blob/master/4th/practice.md>
  - 今回の内容を復習できる問題集です。
  - 不明点があれば, 気軽にサポーターに質問してください。

---
# お疲れさまでした
