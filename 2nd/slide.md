# Perl入学式 第2回

## 構文基礎編

___
## 諸注意
- 会場について
    - 飲食・喫煙・トイレetc

- 写真撮影について
    - 写真撮影NGな方は、お手数ですが申し出てください。

    - 写真はPerl普及団体の [JPA ( Japan Perl Association )](https://japan.perlassociation.org/)への活動報告に利用します。

___
## 講師紹介

- 講師・サポーター紹介

___
## 皆さんで自己紹介
- せっかく今日集まったので、同じテーブルのメンバーで自己紹介をしましょう。

- 話題は自由ですが、以下がオススメです。

    - 名前(ハンドルネーム)

    - なぜPerlを勉強してみようと思ったか

    - なぜPerl入学式に参加してみようと思ったか

___
## 今日の流れ
- 前回の復習
- スカラー変数
- 四則演算と文字列連結
- 標準入力
- 条件分岐（ if文）
- 比較演算子（ <, >, ==, !=, eq, ne, gt, lt ）
- 論理演算子（ &&, || ）
- 配列
- 繰り返し（ for文 ）
- 配列の操作( join, split, push, pop, shift, unshift, reverse, sort )

---
# 前回の復習

___
## 前回の復習
### ターミナルからディレクトリ操作
今日作成するPerlスクリプトを格納する `2nd` フォルダをターミナルから作成しましょう。

```bash
    $ cd                    # ホームディレクトリに移動する
    $ pwd                   # 現在のパスを表示する
    $ ls -l                 # ファイル・フォルダの一覧を表示する
    $ mkdir perl-entrance   # perl-entrance というフォルダを作成する
    $ cd perl-entrance      # 作成した perl-entrance フォルダに移動する
    $ mkdir 2nd             # 2nd というフォルダを作成する
    $ cd 2nd                # 作成した 2nd というフォルダに移動する
```

第1回目で `perl-entrance` ディレクトリを作成している方は、4行目の `mkdir perl-entrance` は省略してください。

___
## 前回の復習
### おまじない
プログラムを書くときに必要な記述を「おまじない」と称することがあります。

Perlでは以下の3行が「おまじない」となります。

```perl
    #!/usr/bin/env perl
    use strict;
    use warnings;
```

以下、この資料のサンプルコードでは紙面の都合上｢おまじない｣を省略します。

しかし、皆さんは**必ず記述してください**。

___
## 前回の復習
### Hello, World!(hello.pl)
実行すると `Hello, World!` と表示するプログラムを作成しましょう。

エディタで以下のスクリプトを書き、 `2nd` フォルダ内に `hello.pl` という名前で保存します。

```perl
    #!/usr/bin/env perl
    use strict;
    use warnings;

    print "Hello, World!\n";
```

「おまじない」込みで書くので、このようになります。

___
## 前回の復習
### Hello, World!(hello.pl)解説

```perl
    # おまじないはスペースの都合省略
    print "Hello, World!\n";
```

- `print` は、ターミナルに文字を表示する命令。

- 表示したい文字列はダブルクォーテーション `" "` で囲む。

    - 表示したい文字列 `Hello, World!`

    - `\n` は改行を意味する

- 行の最後に `;` を忘れずに！

___
## 前回の復習
### Hello, World!(hello.pl)の実行

```bash
    $ perl hello.pl

    Hello, World!
```

1. ターミナルで操作する。

1. `perl` の引数に作成したファイル名の `hello.pl` を渡して、enterキーを押します。

    - プログラムに渡される情報、値などを**<ruby>引<rt>ひき</rt>数<rt>すう</rt></ruby>**と言う

    - この例では `hello.pl` が引数にあたる

1. プログラムの中に書いた文字列 `Hello, World!` が表示される。


___
## 前回の復習
### 皆さんの質問をお待ちしてます！
- ここまでが前回の復習となります。

- 不明点がある方は・・・？

    - サポーターに聞いてみる

    - <a href="http://www.perl-entrance.org/handout.html" target="_blank">Perl入学式の公式サイト</a>で復習する

    - Perl入学式の<a href ="https://docs.google.com/forms/d/e/1FAIpQLScbWyg-cgcqilW7-BpKagRm2ldBhvwRBNr2N5eg3LHOK13FGw/viewform" target="_blank">slack</a>で質問してみる

---
# スカラー変数

___
## スカラー変数
### 変数とは?
- ｢**<ruby>変数<rt>へんすう</rt></ruby>**｣は、いわば｢データを格納できる箱｣です。

- Perlの変数には、｢スカラ変数｣、｢<ruby>配列<rt>はいれつ</rt></ruby>｣、｢<ruby>連想配列<rt>れんそうはいれつ</rt></ruby>(ハッシュ)｣という3つの種類があります。

- 3種類の変数は、それぞれの変数の型を示す **シジル(sigil)** という記号で区別されます。

    1. スカラ変数($)：1つの要素を格納する。

    1. 配列(@)：複数の要素を「順番に」格納する。

    1. ハッシュ(%)：複数の要素を「名前 => 値」の組み合わせで格納する。

- 配列は第2回、ハッシュ（連想配列）は第3回で解説します。

___
## スカラー変数
### スカラー変数・・・その前に「コメント」
```perl
    print "Hello World!";   # -- ここがコメント部 --

    # print "Hello! Perl Entrance!"; 行頭に # があるため、printは実行されない
```

- 各プログラム言語にはスクリプトやプログラムをわかりやすくするために、コメントを入れる仕組みがあります。

- Perlでは、 `#` より右にある文字列は全てコメントとして扱われます。

- コメントは実行されません。

- この資料の中でも、 コメントを使ってコードに補足を行います。

___
## スカラー変数
### スカラー変数を利用する

```perl
    my $foo;    # 変数を宣言する
    $foo = 1;          # 右辺の 1 を左辺の $foo に入れる
    print "$foo\n";    # 1
```

- 変数を初めて使うときは、先頭に `my` をつけます。変数が利用できるようにすることを「**変数を宣言**する」といいます。

- スカラ変数の先頭には、`$foo` のように `$` をつけます。 `$` は`スカラ(scalar)`の `S` 、と覚えるとよいでしょう。

- `=` という記号(代入演算子)を使うことで、「右辺の値」を「左辺のスカラー変数 `$foo` 」に入れる(代入する)ことができます。

___
## スカラー変数
### スカラー変数を利用する
```perl
    my $foo;    # 変数を宣言する
    $foo = 1;          # 右辺の 1 を左辺の $foo に入れる
    print "$foo\n";    # 1

    $foo = "Hello World";   # 宣言済みなので my は不要
                            # 右辺の "Hello World" が 左辺の $foo に入る
    print "$foo\n";         # Hello World
```

- 宣言した変数を2回目以降に使うときは、 `my` は不要です。`my` は変数を宣言する最初のみ必要です。

- 値が入っているスカラー変数に別の値を代入すると、中身が上書きされます

___
## スカラー変数
### 仮の変数名（メタ構文変数）
```perl
    my $foo;
    my $bar = 1;
    $bar = "Hello World";
```
- プログラム言語の参考書には以下の単語が変数名として利用されることがあります。

    - foo, bar, baz

    - hoge, piyo, fuga

- これら「意味のない名前」をつけることで、「サンプル用」「例示用」の変数ということを明示するためです。

- このような単語を使った変数を「**メタ構文変数**」と呼称します。

- これらの変数名は現場のコードでは利用しないようにしましょう。


___
## スカラー変数
### クォーテーションによる表示の違い
```perl
    my $foo = 1;

    print "$foo\n"; # ダブルクォーテーションで囲うと「1」が表示される

    print '$foo\n'; # シングルクォーテーションで囲うと「$foo\n」が表示される
```

-  `print` を使うことで変数を表示することができます。

- 変数を表示する場合は、 `" "(ダブルクォーテーション)`の中に変数を書きましょう。

    - `" "` の中に変数を書くと、その変数の中身が表示されます。

    - `' '` の中では、変数の中身ではなく、書いてあるままに表示されます。

___
## スカラー変数
### エラーチェック

変数を使い始めると、プログラムの行数が増え、エラーが入り込むことが多くなってきます。

perlでは `perl -wc hoge.pl`と `wc`オプションを付けることで、スクリプトを実行する前に、Perlの文法に合っているかどうかのチェックが可能です。

```bash
    $perl -wc foo.pl

    foo.pl syntax OK    # この表示が出れば、文法上の問題はない
```

___
## スカラー変数
### エラーメッセージ
```perl
    #!/usr/bin/env perl
    use strict;
    use warnings;

    my $hoge = "Hello"  # "hello"の後にセミコロンがない
    print "$hoge\n";
```
- よくありがちなエラーとして、行末の「セミコロン `;` を忘れる」というものがあります。
- 先程のシンタックスチェックや、お約束の3行を書いた場合は次のようなエラーがでます。

```
    syntax error at foo.pl line 7, near "print"
    Execution of foo.pl aborted due to compilation errors.
```

- この場合、7行目のprintの周辺でシンタックスエラーが発生しているという意味になります

___
## スカラー変数
### エラー文は怖くない
Perlに限らず、プログラムのエラーメッセージのほとんどは英語で表示されます。

最初は戸惑うかもしれませんが、エラーメッセージ中にある行番号を手がかりに**直前・直後の行**でおかしいところを探してみましょう。

また、エラーメッセージそのものをGoogleなどで検索したり、翻訳することでエラー解決への手がかりを掴むこともできます。

エラーが出るのは悪いことではありません。直すべき場所を明示してくれるありがたい指針です。

**エラーを出さずにプログラムを習得することはできません。**

落ち着いて対処していきましょう。

___
## スカラー変数
### 練習問題 (scalar\_practice.pl)
- Perl入学式とYAPCの情報をスカラ変数に格納し、それらの値を表示するスクリプト`scalar_practice.pl`を作成しよう！

    - `seminar_name` この勉強会の名前
    - `date` 今日の日付
    - `venue_name` 会場名
    - `next_yapc_pref` 次回のYAPCの場所

- 「お約束」の3行を忘れずに！

---
# 四則演算と文字列連結

___
## 四則演算と文字列連結
### 基本的な演算子(足し算・引き算)
```perl
my $foo = 4;
my $bar = 2;
my $result;

# 足し算 +
$result = $foo + $bar;    # 足し算 して $result に代入する
print "$foo + $bar = ";   # 式の表示だけ。改行はしない。
print "$result\n";        # 上の式に続けて $result を表示する

# 引き算 -
$result = $foo - $bar;    # 足し算 して $result に代入する
print "$foo - $bar = ";   # 表示だけ。改行はしない。
print "$result\n";        # 上の式に続けて $result を表示する
```

- 算数と同じ + と - が利用できます。

___
## 四則演算と文字列連結
### 基本的な演算子(掛け算・割り算)
```perl
my $foo = 4;
my $bar = 2;
my $result;

# 掛け算 * （アスタリスク）
$result = $foo * $bar;    # 掛け算 して $result に代入する
print "$foo * $bar = ";   # 表示だけ。改行はしない。
print "$result\n";        # 上の式に続けて $result を表示する

# 割り算 / （スラッシュ）
$result = $foo / $bar;    # 足し算 して $result に代入する
print "$foo / $bar = ";   # 表示だけ。改行はしない。
print "$result\n";        # 上の式に続けて $result を表示する
```

___
## 四則演算と文字列連結
### 基本的な演算子(べき乗・剰余)
```perl
my $foo = 4;
my $bar = 2;
my $result;

# べき乗 **
$result = $foo ** $bar;   # 4 の 2乗 を $result に代入する
print "$foo ** $bar = ";   # 式の表示だけ。改行はしない。
print "$result\n";        # 上の式に続けて $result を表示する

# 剰余 %
$result = $foo % $bar;    # 4 を 2 で割った余りを $result に代入する
print "$foo % $bar = ";   # 表示だけ。改行はしない。
print "$result\n";        # 上の式に続けて $result を表示する
```

___
## 四則演算と文字列連結
### 剰余の使い所
<ruby>**剰余**<rt>じょうよ</rt><ruby>は、初めて聞く言葉かもしれません。利用例を解説します。

```perl
    print 100 % 7;    # 100 / 7 の余りである 2
```

例えば「今日の100日後の曜日」を求めるとき、100日分カレンダーを辿るのは大変です。

1週間は7日なので、7日後は同じ曜日となります。14日後も同じ曜日となります。21日、28日、35日... 7の倍数日後は同じ曜日になります。

これを利用し、100日 を 7日 で割ってみます。剰余は 2 となります。

明日の曜日と同じであれば剰余は 1、 明後日と同じ曜日であれば 2、 と簡単に計算が可能です。

___
## 四則演算と文字列連結
### 代入演算子の性質
```perl
    my $foo = 4;

    $foo = $foo * 3;  # 右辺の計算結果( 4 * 3 )が、左辺の $foo に代入される

    print "$foo\n";   # 12
```
- 代入演算子 `=` は、算数のイコールとは性質が異なります。

    - 算数　　　：左辺と右辺が等しいことを示す

    - プログラム：右辺の計算結果を左辺に代入する

- 上記の例では右辺の「 $foo * 3 」つまり 12 が `=` の左辺 `$foo` に代入されます。

___
## 四則演算と文字列連結
### 省略記法
代入演算子（ `=` ）を利用して、変数の中身を書き換える処理は多いため、専用の記法が用意されています。
```perl
    my $fuga = 100;
    my $hoge = 50;

    $fuga += 1;    # $fuga = $fuga + 1;と同じ
    print "$fuga\n";    # 101
    $fuga -= 1;         # $fuga = $fuga - 1;と同じ
    print "$fuga\n";    # 100

    $fuga *= 2;         # $fuga = $fuga * 2;と同じ
    print "$fuga\n";    # 200
    $fuga /= $hoge;     # $fuga = $fuga / $hoge と同じ
    print "$fuga\n";    # 4
```

___
## 四則演算と文字列連結
### インクリメント
1 ずつ加算することを「インクリメント」といいます。この処理も多用するので、専用の記法が用意されています。
```perl
    my $foo = 4;

    $foo = $foo + 1;# 代入演算子を利用
    print "$foo\n"; # 5

    $foo += 1;      # 省略記法
    print "$foo\n"; # 6

    ++$foo;         # 前置インクリメント
    print "$foo\n"; # 7

    $foo++;         # 後置インクリメント
    print "$foo\n"; # 8
```

前置と後置の違いは[こちら](https://tutorial.perlzemi.com/blog/20180224151948.html)を参照

___
## 四則演算と文字列連結
### 演算の順番
```perl
    my $foo = 2 + 4 * 3;
    print "$foo\n";    # 14

    my $bar = ( 2 + 4 ) * 3;
    print "$bar\n";    # 18
```
- 演算の順序は、 `( )` を付けることで変更することができます。

- 通常の数学と同じく、Perlも「足し算･引き算」より「掛け算･割り算」の優先順位が高いです。

- 2行目では `( )` を付けることで優先順位を変え、「足し算」を先に計算させています。

___
## 四則演算と文字列連結
### 文字列連結
```perl
    my $foo = 'hoge';
    my $bar = 123;

    print "$foo$bar\n";         # hoge123

    print $foo . $bar . "\n";   # hoge123

    my $buz = $foo . $bar;
    print $buz . "\n";          # hoge123
```

- `.` (ドット)で文字列や変数を連結することができます。

- 連結した文字列や変数を、別の変数に代入することも可能です。

___
## 四則演算と文字列連結
### 数値演算と文字列連結の混合
数値演算と文字列連結を混ぜた場合の「アンチパターン（良くない例）」を示します。

    my $now = 2019;
    my $last_showa = 1988;
    print "今年は平成" . $now - $last_showa . "年です\n"; # -1988年です
「-1988年です」と、おかしな結果になります。これは演算子の優先順位が `.` と `-` で同じであり, 左結合のため, 左から演算されるためです.

1. まず 「`今年は平成`」（文字） と 「`2018`」（数字） が文字連結されます。（結果：「今年は平成2018」）

1. 次に、「`今年は平成2018`」（文字） から 「`1988`」（数字）を引き算しようとし、おかしな結果になります。

___
## 四則演算と文字列連結
### 数値演算と文字列連結は分ける
文字と数値計算を明確に分けてから、 計算してから連結するのが確実です.
```perl
    my $now = 2019;
    my $last_showa = 1988;

    print "今年は平成" . ( $now - $last_showa ) . "年です\n";
    # 今年は平成31年です

    my $heisei = $now - $last_showa;
    print "今年は平成" . $heisei . "年です\n";
    # 今年は平成31年です
```
- 1番目のprint文のように、`( )`で演算の順序を変更することで、正しい結果になります。

- 2番目のように、計算結果を別の変数に入れてから連結するのも良いでしょう。

___
## 四則演算と文字列連結
### 数値演算と文字列連結は分ける

演算の優先順位と結合方向(演算の向き)はperldocの[perlop](http://perldoc.jp/docs/perl/5.22.1/perlop.pod#Operator32Precedence32and32Associativity)の項に詳細が記載されています

ただし、これを覚えるのも、他の人に読んでもらうのも大変な労力です。

`( )`で演算の順番を明確に示す、数値演算と文字列の連結は分けて書くなど、わかりやすい記述を心がけましょう。

___
## 四則演算と文字列連結
### 練習問題(sansuu1.pl)
以下の問題をPerlの四則演算を使って、変数を使わずに解いて表示してください。

- １＋２＋３＋４＋５＋６＋７＋８＋９＋１０

- １００ ー　２００

- １０００円の品物を消費税８%で買った時の税込価格

- 半径５mの円の面積（円周率は３．１４とする）

___
## 練習問題(sansuu2.pl)
以下の問題をPerlの四則演算を使って解いてください。

`my $pizza = 10` を使って解いて表示してください

- １０個のピザを５人で分けた時の、一人当たりの個数

- １０個のピザを３人で分けた時の、余りの数

---
# 標準入力

___
## 標準入力
### 入力とは？
- これまでは、あらかじめスクリプトに書かれた文字や数字を表示してきました。

- スクリプトの実行の都度、中身を変える方法として「入力」を用いる方法があります。

- プログラムやコンピュータに様々な数値や文字列を与えることを「入力」と言います。

    - キーボードからの入力、ファイルからの入力、音声入力、カメラ、画面へのタッチ・・・

- 様々な入力のうち、キーボードから入力されるテキストデータのことを<ruby>**標準入力**<rt>ひょうじゅんにゅうりょく</rt></ruby>(Standard Input)といいます。

- 入力の終わりはEnterキー 又は returnキー　となります。

___
## 標準入力
### Perlで標準入力を受け取る
```perl
    my $str = <STDIN>;  # 標準入力から文字列を受け取り、変数 $str に代入する
    chomp $str;         # $strの中の末尾の改行を削除する
    print $str;         # $strを表示する
```

- `Perl` では、この「標準入力」をスクリプトの中で `<STDIN>` と表現します。

- 1行目では、 `<STDIN>` で端末から入力された文字列を受け取り、受け取った文字列を変数 `$str` に代入しています。

    - 文字列（Strings）を表す変数として `$str` がよく利用されます。

- 2行目では `chomp` で行末の改行を削除しています。

    - `<STDIN>` は改行が含まれているため、必須の処理です。

___
## 標準入力
### Perlで標準入力を受け取る
```perl
    print 'input Season > ';    # 入力を促すメッセージ

    my $season = <STDIN>;   # 標準入力 <STDIN> で入力されたものを $season に入れる

    chomp $season;   # $season に格納された入力から、末尾の改行を削除する

    print "Alice loves $season\n";    # 変数を表示して改行する
```

- このコードを実行して、 `<STDIN>` がどのような働きをするか見てみましょう。

- このように、標準入力によってスクリプトの実行結果を変えることが可能です。

___
## 標準入力
### 練習問題 (hello\_stdin.pl)
    Your Name?> Taro
    Hello Taro!
    Your OS?> macOS
    macOS is useful OS!
- "Your Name?> " と画面に表示して名前の入力を求め、入力された名前の左側に Hello、右側に "!" を付けて表示するスクリプト `hello_stdin.pl` を作成しよう。

- さらに続けて "Your OS?> " と画面に表示して使用中の OS の入力を求め、入力されたOS名の右側に "is useful OS!" を付けて表示させるようにもしてみましょう。

___
## 標準入力
### 練習問題 (calc.pl)
    1 + 2 = 3
    1 - 2 = -1
    1 * 2 = 2
    1 / 2 = 0.5
- 標準入力`<STDIN>`から0以外の整数を2つ読み込み、 それらを四則演算(`+`, `-`, `*`, `/`)した結果を上の例のように表示するスクリプト `calc.pl`を作成しよう.

---
# if文

___
## if文
### 条件分岐
私たちは状態に応じて行動を変化させることがあります。例えば、以下は信号の例です。

- 「青」信号なら横断歩道を渡る

- 「赤」信号なら横断歩道を渡らない

スクリプトも変数の状態や、条件に応じて動きを分岐させることができます。

これを **条件分岐** といいます。

Perlでは<ruby>**IF文**<rt>イフぶん</rt></ruby>を使って条件分岐を表します。

___
## if文
### 真と偽

条件分岐をする際には、条件が 真 / 偽 のどちらであるか？という判定が必要です。

- 条件を満たしている ：<ruby>**真**<rt>しん</rt></ruby>

- 条件を満たしていない：<ruby>**偽**<rt>ぎ</rt><ruby>

真、 偽 の判定に用いる式を **条件式** といいます。

___
## if文
### Perlにおける真偽値
Perl入学式では、次の5つの値を｢偽｣の値として扱います。

1. 数値｢ `0` ｣

1. 文字列｢ `'0'` ｣

1. 文字列｢`''`｣（シングルクォーテーションの間に何もない。空文字ともいう。）

1. undef  （Perl入学式では登場しないので説明しない）

1. 空のリスト「 `()` 」（Perl入学式では登場しないので説明しない）

そしてこれ以外の値は、Perlでは全て「真」として扱われます。

明示的な「真」の値が必要な場合、 数値の `1` を使う場合が多いです。

___
## if文
### true と false
`true` や `false` という単語に 真 / 偽 の意味を持つキーワードとして扱っているプログラミング言語もあります。

しかし、Perlは `true` や `false` などで真偽値を表すことはできません。また特別な意味もありません。

Perl で 条件式の結果が `false` という文字列であった場合、先にでてきた「偽の値」には含まれていないので、「真」と判断されます。

___
## if文
### if文の解説
```perl
    if ( 条件式 ) {
        条件式が「真」の時に実行されるスクリプト ;
    }
    else {
        条件式が「偽」の時に実行されるスクリプト ;
    }
```

```perl
    if ( 信号が青 ) {   # 信号に例えた例
        横断歩道を渡る ;
    }
    else {
        横断歩道を渡らない ;
    }
```

この { } の部分を**ブロック**と呼びます。

___
## if文
### if文の例
```perl
    if ( 条件式 ) {       # 明示的な「真」の値である 1

        条件式が「真」の時に実行されるスクリプト ;
    }
```

```perl
    if ( 1 ) {           # 明示的な「真」の値である 1

        print "OK\n";    # 条件式の結果が｢真｣なので表示される

    }
```

```perl
    if ( 0 ) {           # 「偽」の値である 0

        print "OK\n";    # 条件式の結果が｢偽｣なので表示されない

    }
```

___
## if文
### 数値の比較演算子
if文の条件式で数値同士を比較するときは、このような記号を用いた**比較演算子**を使います。
```perl
    ==  # 右辺と左辺が等しいならば「真」

    !=  # 右辺と左辺が等しくないならば「真」

    <   # 右辺より左辺が小さいならば「真」

    >   # 右辺より左辺が大きいならば「真」

    <=  # 右辺が左辺以上ならば「真」

    >=  # 右辺が左辺以下ならば「真」
```

___
## if文
### 数値を使った条件分岐
```perl
    my $foo = 1;        # 代入演算子

    if ( $foo == 1 ) {  # 比較演算子を使った条件式
        print "OK\n";   # 条件が｢真｣の場合
    }
    else {
        print "NG\n";   # 条件が｢偽｣の場合
    }
```

`==` は **右辺と左辺が数値として等しければ真** であることを意味します

ここでは `$foo` が `1` と等しい場合に「真」となり、 `OK` という文字が表示されます

`$foo` が `1` と等しくない場合は、「偽」となり `else` に処理が移って `NG`　という文字が表示されます

___
## if文
### 代入演算子(=)と比較演算子(==)の混合
```perl
    my $foo == 1; # NG

    my $bar =  1; # OK
```

変数の宣言と同時に変数に代入する際に用いるのは `=` 、イコール1つの代入演算子です。

1行目は比較演算子 `==` と、代入の `=` を間違えています。

この場合、実行すると以下のエラーが出ます

    Useless use of numeric eq (==) in void context

「おまじない」の3行を忘れた場合はエラーが出ずに危険です。

___
## if文
### 代入演算子(=)と比較演算子(==)の混合
```perl
    my $foo = 1;

    if ($foo =  1) { print $foo } # NG

    if ($foo == 1) { print $foo } # OK
```

条件式に注目してください。

条件式で用いる比較演算子 `==` と、変数の代入に用いる `=` を間違えています

この場合、実行すると以下のエラーが出ます

    Found = in conditional, should be ==

「おまじない」の3行を忘れた場合はエラーが出ずに危険です。

___
## if文
### 文字列の比較演算子
```perl
    eq  # equal

    ne  # not equal

    gt  # greater than

    ge  # greater equal

    lt  # less than

    le  # less equal
```
文字列を比較する場合は `eq` や `ne` といった単語を用いた比較演算子を使います。

「文字列の大小」とは、文字列の長さではありません。辞書順に並べた時に前にくるものが小さく、後ろにくるものが大きいという意味です。

___
## if文
### 文字列を使った条件分岐
```perl
    my $foo = 'hello';

    if ( $foo eq 'hello' ) {
        print "OK\n";   # 条件式が真なので OK と表示される
    }
    else {
        print "NG\n";
    }
```

文字列を比較しているので、 `==` ではなく `eq` を用います。


___
## if文
### 数値 と 文字列 の比較を混合させるアンチパターン
```perl
print "eq で評価すると、";
if ( '51.0' eq 51 ) {
    print "文字列'51.0' と 数値 51 は等しい\n";
}
else {
    print "文字列'51.0' と 数値 51 は等しくない\n"; # こちらが表示される
}
```

`eq` は文字列を比較するときに使う比較演算子です

このため、条件式の左辺・右辺は文字列として **異なる** と判断されます

___
## if文
### 数値 と 文字列 の比較を混合させるアンチパターン
```perl
print "== で評価すると、";
if ( '51.0' == 51 ) {
    print "文字列'51.0' と 数値 51 は等しい\n"; # こちらが表示される
}
else {
    print "文字列'51.0' と 数値 51 は == 等しくない\n";
}
```

条件式の比較演算子を `eq` から `==` に変更すると、 先ほどとは逆の結果となります.

`==` は数値を比較するときに使う比較演算子です。

このため、条件式の左辺・右辺は数値として **等しい** と判断されます。

___
## if文
### 複数の条件分岐
```perl
    my $foo = 1;

    if ( $foo == 1 ) {
        print '$foo is One' . "\n";
    }
    elsif ( $foo == 2 ) {
        print '$foo is Two' . "\n";
    }
    elsif ( $foo == 3 ) {
        print '$foo is Three' . "\n";
    }
    else {
        print '$foo is not even One, even Two, even Three' . "\n";
    }
```
- `elsif`を使うことで、分岐条件を増やすことができます。

- `else if` ではなく, **`elsif`** です。

___
## if文
### 練習問題(signal.pl)
以下のコードをコピペして、以下の条件に合うように作り変えてください。

- `$signal` が `blue` の時は'WALK'と表示する
- `$signal` が `red` の時は'Dont WALK'と表示する
- `$signal` が `yellow` の時は'Please Stop'と表示する

```perl
    #!/usr/bin/env perl
    use strict;
    use warnings;

    my $signal = 'blue';

    if ( ????? ) {
        ?????????????
    }
```

---
# 論理演算子

___
## 論理演算子
### && と ||
```perl
    && # かつ

    || # または
```

`if文`で複雑な条件を扱いたいときは、`論理演算子`を用いて複数の条件を連結します。

- `&&` 演算子は｢かつ・AND｣の意味を持ち、両辺の条件が真となるときのみ真となる。

- `||` 演算子は｢または・OR｣の意味を持ち、条件の片方1つでも真ならば真となる。

___
## 論理演算子
### 論理演算子を使った複雑な条件式( && )
```perl
    my $foo = 10;

    if ( $foo > 0 && $foo % 2 == 0 ) {  # $fooが 0 より大きい かつ 2 で割り切れる
        print "&&: OK\n";    # &&: OK
    }
    else{
        print "&&: NG\n"
    }
```

1. `$foo` が 0 より大きいので、`$foo > 0`　を満たす

1. `$foo` を 2 で割った剰余は 0 なので、`$foo % 2 == 0` も満たす

1. 「1. かつ 2. が 真」の条件を満たすので条件式は 真 となり、`&&: OK` と表示される

___
## 論理演算子
### 論理演算子を使った複雑な条件式( || )
```perl
    my $foo = 10;

    if ( $foo > 0 || $foo % 2 == 1 ) {  # $fooが 0 より大きい または 2 で割り切れない
        print "||: OK\n";    # ||: OK
    }
    else{
        print "&&: NG\n"
    }
```
1. `$foo` が 0 より大きいので `$foo > 0`　を満たす

1. 「1. または 2. が 真」の条件のうち、「1. が 真 」を満たすので条件式は 真 となり、`||: OK` と表示される

___
## 論理演算子
### 3つ以上の値を比較する
```perl
    my $small  = 10;
    my $medium = 20;
    my $large  = 30;

    if ( $small < $medium < $large ) {    # 間違った条件式！
        print "小さい順に並んでます\n";
    }
```

`$small < $medium < $large` のように、3つ以上の値を同時に比較することはできません。

下記のようなエラーとなります。

    syntax error at sample.pl line 5, near "$medium <"

___
## 論理演算子
### 論理演算子で3つ以上の値を比較する
```perl
    my $small  = 10;
    my $medium = 20;
    my $large  = 30;

    if ( $small < $medium && $medium < $large ) {
        print "小さい順に並んでます\n";
    }
```
`$small < $medium` かつ `$medium < $large` というように、 関係演算子を使って比較します

___
## 練習問題(question\_num.pl)
```perl
    #!/usr/bin/env perl
    use strict;
    use warnings;
    my $answer = 10;
```
簡単な数当てゲーム `question_num.pl`を作成しよう

ターミナルから数字を一つ入力し、その数字とスクリプト中の `$answer`　と比較して以下のように表示してください。

- `$answer` と一致したら `OK` と表示

- `$answer` より大きければ `too big` と表示

- `$answer` より小さければ `too small`　と表示

- （余裕があれば）入力した値が、 `$answer`から-5〜+5の範囲内( 5〜15 )の場合、 `near`と表示する

---
# 配列

___
## 配列
### 配列とは
```perl
    my @array = ( 1, "foo", 3 );
```

1行目の右辺、 `( 1, "foo", 3 )` の部分を **リスト** と呼びます。

この右辺はスカラー値の集合、まとまりであることに注目してください。

このリストをPerlで操作するために <ruby>**配列**<rt>はいれつ</rt></ruby>変数 に格納します。配列に含まれる `1`, `"foo"`, `3` それぞれを **要素** といいます。

スカラー変数と同様に `=` 演算子を使うことで、右辺のリストを左辺の配列に代入することができます。

配列は変数名の前に `@` をつけます. `@` は `アレイ(array)` なので `@rray` と覚えるとよいでしょう. (arrayは配列を意味する英単語です)

___
## 配列
### 配列変数の表示
```perl
    my @array = ( 1, "foo", 3 );

    print "@array\n";    # 1 foo 3
```

配列変数はスカラー変数と同じく `" "` ダブルクォーテーションで囲むことで変数の表示が可能です。

___
## 配列
## 配列の要素にアクセスする
```perl
    my @array = ( 1, "foo", 3 );

    print "$array[0]\n";    # 1
```
配列 `@array` の中の要素にアクセスする方法は `$array[0]` となります。

この時、シジルが配列を示す `@` からスカラー変数の `$` になっていることに注目！

これは **取り出す要素の数が1つだけなのでスカラー変数となる** ためです。

> - スカラ変数：1つの要素を格納できる
> - 配列、ハッシュ：複数の要素を格納できる (第1回Part4より)

___
## 配列
### 配列の添字
```perl
    my @array = ( 1, "foo", 3 );

    print "$array[0]\n";    # 1
    print "$array[1]\n";    # foo
    print "$array[2]\n";    # 3
```

配列の1つ1つの要素にアクセスする場合は `$変数名[添字]` を使います。

添字は数字で指定し、添字は先頭の 0 からスタートして、末尾に向けて 1 ずつ増えます。

___
## 配列
### 配列の添字
```perl
    my @array = ( 1, "foo", 3 );
    my $i = 1;
    print "$array[$i]\n";    # foo
```

配列の添字には、数値が入ったスカラー変数を置くことも可能です。

___
## 配列
### 配列要素への代入
```perl
    my @array = ( 1, "foo", 3 );
    $array[0] = "bar";    # 先頭の要素に文字列 "bar" を代入する
    print "@array";       #bar foo 3
```

配列に新たな要素を代入する際は、取り出すときと同様に添字を使います。

___
## 配列
## 配列要素同士の計算
```perl
    my @array = ( 1, "foo", 3 );

    my $sum = $array[0] + $array[2];     # my $sum = 1 + 3

    print "$sum\n"    # 4
```

配列の要素はスカラ変数と同じように扱えるので、このような計算も可能です。

___
## 配列
### 配列の要素数
```perl
    my @array = ( 1, "foo", 3 );

    my $count_array_element = scalar @array;    # 要素の数を取得
    print "$count_array_element\n";             # 3

    my $last_array_index = $#array;             # 配列の末尾の要素の添字を取得
    print "$last_array_index\n";                # 2
```

配列を `scalar` 演算子に与えると、配列に格納されている**要素の個数**を取得できます。

配列 `@array` に対して `$#array` と書くことで、配列に格納されている**末尾の要素の添字**を取得できます。

___
## 配列
## 範囲演算子

連続する数字を配列に代入したいときは、 **範囲演算子** `..` が便利です。

```perl
    my @array1 = ( 1 .. 5 );
    print "@array1";    # 1 2 3 4 5
```

- `1 .. 5` と書くことで、 1 から 5 までの連続する値を配列に代入できます。

- ただし、必ず右側の値が左側の値より大きい必要があります。

```perl
    my @array2 = ( 5 .. 1 );        # 範囲演算子の左が右より小さい
    print "@array2\n";              # （何も表示されない）
    print scalar @array2 . "\n";    # 要素数は 0 、何も入っていない空の配列
```

---
# 繰り返し（for文）

___
## 繰り返し（for文）
### forループ
配列の中身を順番に処理する方法として、 **for文** があります。
```perl
    my @array = ( 1, "foo", 3 );  # 配列を宣言

    for my $element (@array) {    # 配列の先頭の要素から順に $element に代入する
        print "$element\n";       # $element を改行付きで表示する
    }
```

1. for文の `()` 内の配列から、先頭の要素が `$element` に代入される。

1. ブロック `{ }` の中の処理が行われる（ここでは改行付きで表示）

1. `()` 内の配列の次の要素が `$element` に代入され、ブロック内の処理を行われる。

1. `()` 内の配列の要素全てを表示したら終了する。


___
## 繰り返し（for文）
### forループと範囲演算子
```perl
    for my $i ( 1 .. 50 ) {
        print "$i\n";    # 1 から 50 まで 1つずつ改行されて表示される
    }
```

配列のところで学習した範囲演算子 `..` を利用することで、決まった回数分だけ処理を繰り返すことができます。

```perl
    for my $i ( 1 .. 50 ) {
        print "Hello, World!\n";    # Hello, World! が 50回表示される
    }
```

___
## 繰り返し（for文）
### 練習問題(for.pl)

以下の配列 `@array` の要素をfor文を使って表示してください。

```perl
    my @array = ( 'Perl', 'PHP', 'Ruby' );
```

___
## 練習問題(even.pl)

for文を使って `1` から `100` までのうち、偶数のみを表示してください。

- ヒント

    - 計算の剰余を求める `%` 演算子

    - 例えば ` 5 % 3 ` は 「5 を 3 で割った余り」ですので，`2` が求まります。

    - 偶数の特徴は？

___
## 練習問題(fizzbuzz.pl)
1から100までの数字について、 以下のようなルールに従って表示を行う `fizzbuzz.pl` を作成しよう!

- その数字が `3` で割り切れるなら `Fizz` と表示する

- `5` で割り切れるなら `Buzz` と表示する

- `3` でも `5` でも割り切れるなら `FizzBuzz`

- `3` でも `5` でも割り切れないなら`その数字`

> コンピュータサイエンス学科卒業生の過半数にはそれ(fizzbuzz)ができないのだ<br>
> ()部はsironekotoro追加
> <div style="text-align: right;">参考:[どうしてプログラマに・・・プログラムが書けないのか?](http://www.aoky.net/articles/jeff_atwood/why_cant_programmers_program.htm)</div>


---
# 配列の関数

___
## 配列の関数
### join, split

**関数** とは、ある働きをもつ機能のことです。

いままで変数の中身を表示してきた `print` も、「表示する」という機能を持つ関数です。

配列の関数をまず2つ紹介します。

- join

- split

___
## 配列の関数
### join
`join` は分割された文字列をくっつけて、1つの文字列にします。

```perl
    my @words = ( 'I', 'Love', 'Perl.' );    # 配列を作る
    my $poem  = join '_', @words;            # 第1引数 _ , 第2引数 @words
    print "$poem\n";                         # 'I_Love_Perl.'
```

- `join` が受け取る第1引数 (上の例では _ アンダースコア) は、配列の要素をくっつける糊のような役割を果たします。

- 第2引数には、対象の配列を渡します。

___
## 配列の関数
### split
`split` は、 `join` とは逆に、指定したパターンに従って文字列を分割します。

```perl
    my $poem  = 'I_Love_Perl.';
    my @words = split /_/, $poem;
    print "@words\n";    # I Love Perl.
```

`split` が受け取る第1引数 (上の例ではアンダースコア) は、文字列を分割する区切りのような役割を果たします。

第2引数には、対象の文字列を渡します。

`/ /` は正規表現リテラルと呼ばれる「文字のパターン」を記述すためのものです。

正規表現については第3回で詳しく説明します。

___
## 配列の関数
### 練習問題 join, split
次の処理をする `join.pl` を作りましょう。

1. `("0120", "123", "XXX")` という配列を作ってください

2. 作成した配列をjoin関数を利用して `-` で連結して表示してください。

次の処理をする `split.pl` を作りましょう。

1. "There's more than one way to do it." という文字列を作り、split関数で `" "`（半角スペース）ごとに分割して配列 `@array` に格納し、表示してください。

___
## 配列の関数
## push, pop, unshift, shift
さきほど、皆さんは配列の基本を勉強しました。

配列の用途は主に2つです。

- 名簿など、要素の **単純な集まり** として表現したい場合。

- ランキングなど、要素間の **順序** 関係を表現したい場合。

これらの用途においては、要素の順番の並べ替えや、要素の追加、取り出しが必要になります。

___
## 配列の関数
### push, pop, unshift, shift

- 要素の追加
    - push
    - unshift

- 要素の取り出し
    - pop
    - shift

___
## 配列の関数
### 追加と取り出しの関係

|       |**追加**|**取り出し**|
|-------|-------|-----------|
|**末尾**|push   |pop        |
|**先頭**|unshift|shift      |

___
## 配列の関数
### push / pop
```perl
    my @array = ( 'Alice', 'Bob' );
    push @array, 'Chris';    # 末尾に要素 Chris を追加する
    print "@array\n";        # Alice Bob Chris

    my $element = pop @array;# 末尾の要素 Chris を取り出す
    print "@array\n";        # Alice Bob
    print "$element\n";      # Chris
```

- 配列の **末尾に要素を追加** するときには `push` を利用します。

- 配列の **末尾から要素を取り出す** ときには `pop` を利用します。

___
## 配列の関数
### unshift / shift
```perl
    my @array = ( 'Alice', 'Bob' );
    unshift @array, 'Chris';    # 先頭に要素 Chris を追加する
    print "@array\n";           # Chris Alice Bob

    my $element = shift @array; # 先頭の要素 Chris を取り出す
    print "@array\n";           # Alice Bob
    print "$element\n";         # Chris
```

- 配列の **先頭に要素を追加** するときには `unshift` を利用します

- 配列の **末尾から要素取り出す** ときには `shift` を利用します

___
## 配列の関数
### 練習問題 (array_pop_shift.pl)
次の処理をする `array_pop_shift.pl` を作りましょう。

1. ('Alice', 'Bob', 'Chris') という配列 `@array` を作ってください。

1. 配列 `@array` から 'Chris' を取り出し、表示してください。

1. 配列 `@array` から 'Alice' を取り出し、表示してください。

___
## 配列の関数
### 練習問題 (array_push_unshift.pl)
次の処理をする `array_push_unshift.pl` を作りましょう。

1. ('Alice', 'Bob', 'Chris') という配列 `@array` を作ってください。

1. 配列 `@array` の末尾に `Diana` を追加し、 ('Alice', 'Bob', 'Chris', 'Diana') という配列を作ってください。

1. 配列 `@array` の最初に `Eve` を追加し、 ('Eve', 'Alice', 'Bob', 'Chris', 'Diana') という配列を作ってください。

1. 配列をfor文で表示してください。

___
## 配列の関数
### reverse
reverse はリストを逆順に並べ替えて、そのリストを返します。
```perl
    my @lang     = ('perl', 'php', 'ruby', 'python', 'java', 'go');

    my @reversed = reverse @lang;

    print "@reversed";    # go java python ruby php perl
```

___
## 配列の関数
### reverseと範囲演算子
連番を逆順で配列に格納したいとき、範囲演算子と組み合わせると便利です。
```perl
    my @array = reverse( 1 .. 5 );

    print "@array\n";    # 5 4 3 2 1
```

___
## 配列の関数
### 文字列sort
sort は配列をルール順に並べ替えて、その配列を返します。

`sort`のみ、あるいは `sort { $a cmp $b } @array` と書くと、「文字列」として昇順（`a`から`z`へ辞書順）にソートします。

```perl
    my @lang        = ('perl', 'php', 'ruby', 'python', 'java', 'go');
    my @sorted_lang = sort @lang;
    print "@sorted_lang\n";    # go java perl php python ruby

    my @num = ( 5, 200, 40, 3, 1 );
    my @sorted_num = sort @num;
    print "@sorted_num\n";     # 1 200 3 40 5
```

___
## 配列の関数
### 数値sort（昇順）
「数値」として昇順（小さい順）にソートするときには以下のようになります。

```perl
    my @num = ( 5, 200, 40, 3, 1 );

    my @sorted = sort { $a <=> $b } @num;

    print "@sorted\n"    # 1 3 5 40 200
```

変数 `$a` と `$b` はsortで使うために予約されているので、 **sort以外で使わないようにしましょう**。

___
## 配列の関数
### 数値sort（降順）
「数値」として降順（大きい順）にソートする場合、以下の2つの書き方ができます。

```perl
    # sortブロック内の $a と $b を逆転させた書き方
    my @num = ( 5, 200, 40, 3, 1 );
    my @sorted1 = sort { $b <=> $a } @num;
    print "@sorted1\n";    # 200, 40, 5, 3, 1

    # sort 結果をreverse で逆転させた書き方
    my @sorted2 = reverse sort { $a <=> $b } @num;
    print "@sorted2\n";    # 200, 40, 5, 3, 1
```

___
## 復習問題

- [practice.md](./practice.md)
  - 今回の内容を復習することができる問題集です。
  - ご不明な点があれば、気軽にスタッフまでお尋ねください。

___
## 練習問題の解答例

- [2019-answer](./answer)
  - 各会場の講師が書いた、練習問題の解答例はこちらで公開しています。
  - ※講義終了後に随時追加していきます

- [2018-answer](https://github.com/perl-entrance-org/workshop-2018/tree/master/2nd/answer)
  - 昨年分の解答例はこちらで公開しています

- [2017-answer](https://github.com/perl-entrance-org/workshop-2017/tree/master/2nd/answer)
  - 一昨年分の解答例はこちらで公開しています

---
## お疲れ様でした!
- 長い時間、Perl入学式第2回お疲れ様でした！

- 是非Perl入学式の[slack](https://docs.google.com/forms/d/e/1FAIpQLScbWyg-cgcqilW7-BpKagRm2ldBhvwRBNr2N5eg3LHOK13FGw/viewform)に参加して、サポーターや参加者の皆さんと交流しましょう。

- 不明点があればslackで是非質問してください。

- 第3回の参加もお待ちしております！


---
# 次回予告
- ハッシュ

- 正規表現

- リファレンスがないとできないこと
